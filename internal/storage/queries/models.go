// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package queries

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

type AccountTypeEnum string

const (
	AccountTypeEnumAsset     AccountTypeEnum = "asset"
	AccountTypeEnumLiability AccountTypeEnum = "liability"
	AccountTypeEnumEquity    AccountTypeEnum = "equity"
	AccountTypeEnumRevenue   AccountTypeEnum = "revenue"
	AccountTypeEnumExpense   AccountTypeEnum = "expense"
)

func (e *AccountTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountTypeEnum(s)
	case string:
		*e = AccountTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountTypeEnum: %T", src)
	}
	return nil
}

type NullAccountTypeEnum struct {
	AccountTypeEnum AccountTypeEnum `json:"account_type_enum"`
	Valid           bool            `json:"valid"` // Valid is true if AccountTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.AccountTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountTypeEnum), nil
}

func (e AccountTypeEnum) Valid() bool {
	switch e {
	case AccountTypeEnumAsset,
		AccountTypeEnumLiability,
		AccountTypeEnumEquity,
		AccountTypeEnumRevenue,
		AccountTypeEnumExpense:
		return true
	}
	return false
}

func AllAccountTypeEnumValues() []AccountTypeEnum {
	return []AccountTypeEnum{
		AccountTypeEnumAsset,
		AccountTypeEnumLiability,
		AccountTypeEnumEquity,
		AccountTypeEnumRevenue,
		AccountTypeEnumExpense,
	}
}

type TransactionSideEnum string

const (
	TransactionSideEnumDebit  TransactionSideEnum = "debit"
	TransactionSideEnumCredit TransactionSideEnum = "credit"
)

func (e *TransactionSideEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionSideEnum(s)
	case string:
		*e = TransactionSideEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionSideEnum: %T", src)
	}
	return nil
}

type NullTransactionSideEnum struct {
	TransactionSideEnum TransactionSideEnum `json:"transaction_side_enum"`
	Valid               bool                `json:"valid"` // Valid is true if TransactionSideEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionSideEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionSideEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionSideEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionSideEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionSideEnum), nil
}

func (e TransactionSideEnum) Valid() bool {
	switch e {
	case TransactionSideEnumDebit,
		TransactionSideEnumCredit:
		return true
	}
	return false
}

func AllTransactionSideEnumValues() []TransactionSideEnum {
	return []TransactionSideEnum{
		TransactionSideEnumDebit,
		TransactionSideEnumCredit,
	}
}

type TransactionStatusEnum string

const (
	TransactionStatusEnumPending TransactionStatusEnum = "pending"
	TransactionStatusEnumPosted  TransactionStatusEnum = "posted"
	TransactionStatusEnumFailed  TransactionStatusEnum = "failed"
)

func (e *TransactionStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionStatusEnum(s)
	case string:
		*e = TransactionStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionStatusEnum: %T", src)
	}
	return nil
}

type NullTransactionStatusEnum struct {
	TransactionStatusEnum TransactionStatusEnum `json:"transaction_status_enum"`
	Valid                 bool                  `json:"valid"` // Valid is true if TransactionStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionStatusEnum), nil
}

func (e TransactionStatusEnum) Valid() bool {
	switch e {
	case TransactionStatusEnumPending,
		TransactionStatusEnumPosted,
		TransactionStatusEnumFailed:
		return true
	}
	return false
}

func AllTransactionStatusEnumValues() []TransactionStatusEnum {
	return []TransactionStatusEnum{
		TransactionStatusEnumPending,
		TransactionStatusEnumPosted,
		TransactionStatusEnumFailed,
	}
}

type UserRoleEnum string

const (
	UserRoleEnumAdmin     UserRoleEnum = "admin"
	UserRoleEnumDeveloper UserRoleEnum = "developer"
	UserRoleEnumReadonly  UserRoleEnum = "readonly"
	UserRoleEnumAuditor   UserRoleEnum = "auditor"
)

func (e *UserRoleEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRoleEnum(s)
	case string:
		*e = UserRoleEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRoleEnum: %T", src)
	}
	return nil
}

type NullUserRoleEnum struct {
	UserRoleEnum UserRoleEnum `json:"user_role_enum"`
	Valid        bool         `json:"valid"` // Valid is true if UserRoleEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRoleEnum) Scan(value interface{}) error {
	if value == nil {
		ns.UserRoleEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRoleEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRoleEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRoleEnum), nil
}

func (e UserRoleEnum) Valid() bool {
	switch e {
	case UserRoleEnumAdmin,
		UserRoleEnumDeveloper,
		UserRoleEnumReadonly,
		UserRoleEnumAuditor:
		return true
	}
	return false
}

func AllUserRoleEnumValues() []UserRoleEnum {
	return []UserRoleEnum{
		UserRoleEnumAdmin,
		UserRoleEnumDeveloper,
		UserRoleEnumReadonly,
		UserRoleEnumAuditor,
	}
}

type UserStatusEnum string

const (
	UserStatusEnumActive              UserStatusEnum = "active"
	UserStatusEnumSuspended           UserStatusEnum = "suspended"
	UserStatusEnumPendingVerification UserStatusEnum = "pending_verification"
)

func (e *UserStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserStatusEnum(s)
	case string:
		*e = UserStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for UserStatusEnum: %T", src)
	}
	return nil
}

type NullUserStatusEnum struct {
	UserStatusEnum UserStatusEnum `json:"user_status_enum"`
	Valid          bool           `json:"valid"` // Valid is true if UserStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.UserStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserStatusEnum), nil
}

func (e UserStatusEnum) Valid() bool {
	switch e {
	case UserStatusEnumActive,
		UserStatusEnumSuspended,
		UserStatusEnumPendingVerification:
		return true
	}
	return false
}

func AllUserStatusEnumValues() []UserStatusEnum {
	return []UserStatusEnum{
		UserStatusEnumActive,
		UserStatusEnumSuspended,
		UserStatusEnumPendingVerification,
	}
}

// Template table for sqlc generation - actual data is in tenant schemas
type Account struct {
	ID          uuid.UUID       `db:"id" json:"id"`
	Code        string          `db:"code" json:"code"`
	Name        string          `db:"name" json:"name"`
	AccountType AccountTypeEnum `db:"account_type" json:"account_type"`
	ParentID    *uuid.UUID      `db:"parent_id" json:"parent_id"`
	Currency    string          `db:"currency" json:"currency"`
	Metadata    json.RawMessage `db:"metadata" json:"metadata"`
	IsActive    bool            `db:"is_active" json:"is_active"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
}

// Template table for sqlc generation - actual data is in tenant schemas
type AccountBalance struct {
	AccountID uuid.UUID       `db:"account_id" json:"account_id"`
	Currency  string          `db:"currency" json:"currency"`
	Balance   decimal.Decimal `db:"balance" json:"balance"`
	Version   int64           `db:"version" json:"version"`
	UpdatedAt time.Time       `db:"updated_at" json:"updated_at"`
}

type ApiKey struct {
	ID         uuid.UUID          `db:"id" json:"id"`
	TenantID   uuid.UUID          `db:"tenant_id" json:"tenant_id"`
	Name       string             `db:"name" json:"name"`
	KeyHash    string             `db:"key_hash" json:"key_hash"`
	KeyPrefix  string             `db:"key_prefix" json:"key_prefix"`
	Scopes     []string           `db:"scopes" json:"scopes"`
	ExpiresAt  pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	LastUsedAt pgtype.Timestamptz `db:"last_used_at" json:"last_used_at"`
	CreatedAt  time.Time          `db:"created_at" json:"created_at"`
}

type Event struct {
	EventID        uuid.UUID       `db:"event_id" json:"event_id"`
	TenantID       uuid.UUID       `db:"tenant_id" json:"tenant_id"`
	AggregateID    uuid.UUID       `db:"aggregate_id" json:"aggregate_id"`
	AggregateType  string          `db:"aggregate_type" json:"aggregate_type"`
	EventType      string          `db:"event_type" json:"event_type"`
	EventVersion   int32           `db:"event_version" json:"event_version"`
	EventData      json.RawMessage `db:"event_data" json:"event_data"`
	Metadata       json.RawMessage `db:"metadata" json:"metadata"`
	CreatedAt      time.Time       `db:"created_at" json:"created_at"`
	SequenceNumber pgtype.Int8     `db:"sequence_number" json:"sequence_number"`
}

type Tenant struct {
	ID           uuid.UUID       `db:"id" json:"id"`
	Name         string          `db:"name" json:"name"`
	Slug         string          `db:"slug" json:"slug"`
	BusinessType pgtype.Text     `db:"business_type" json:"business_type"`
	CountryCode  pgtype.Text     `db:"country_code" json:"country_code"`
	BaseCurrency pgtype.Text     `db:"base_currency" json:"base_currency"`
	Timezone     pgtype.Text     `db:"timezone" json:"timezone"`
	Metadata     json.RawMessage `db:"metadata" json:"metadata"`
	CreatedAt    time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt    time.Time       `db:"updated_at" json:"updated_at"`
}

type TenantUser struct {
	ID          uuid.UUID       `db:"id" json:"id"`
	TenantID    uuid.UUID       `db:"tenant_id" json:"tenant_id"`
	UserID      uuid.UUID       `db:"user_id" json:"user_id"`
	Role        UserRoleEnum    `db:"role" json:"role"`
	Permissions json.RawMessage `db:"permissions" json:"permissions"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
}

// Template table for sqlc generation - actual data is in tenant schemas
type Transaction struct {
	ID             uuid.UUID                 `db:"id" json:"id"`
	IdempotencyKey string                    `db:"idempotency_key" json:"idempotency_key"`
	Description    string                    `db:"description" json:"description"`
	Reference      pgtype.Text               `db:"reference" json:"reference"`
	Status         NullTransactionStatusEnum `db:"status" json:"status"`
	PostedAt       time.Time                 `db:"posted_at" json:"posted_at"`
	Metadata       json.RawMessage           `db:"metadata" json:"metadata"`
	CreatedAt      time.Time                 `db:"created_at" json:"created_at"`
}

// Template table for sqlc generation - actual data is in tenant schemas
type TransactionLine struct {
	ID            uuid.UUID           `db:"id" json:"id"`
	TransactionID uuid.UUID           `db:"transaction_id" json:"transaction_id"`
	AccountID     uuid.UUID           `db:"account_id" json:"account_id"`
	Amount        decimal.Decimal     `db:"amount" json:"amount"`
	Side          TransactionSideEnum `db:"side" json:"side"`
	Currency      string              `db:"currency" json:"currency"`
	Metadata      json.RawMessage     `db:"metadata" json:"metadata"`
	CreatedAt     time.Time           `db:"created_at" json:"created_at"`
}

type User struct {
	ID                  uuid.UUID          `db:"id" json:"id"`
	Email               string             `db:"email" json:"email"`
	EmailVerified       pgtype.Bool        `db:"email_verified" json:"email_verified"`
	PasswordHash        string             `db:"password_hash" json:"password_hash"`
	FirstName           string             `db:"first_name" json:"first_name"`
	LastName            string             `db:"last_name" json:"last_name"`
	Status              NullUserStatusEnum `db:"status" json:"status"`
	LastLoginAt         pgtype.Timestamptz `db:"last_login_at" json:"last_login_at"`
	FailedLoginAttempts pgtype.Int4        `db:"failed_login_attempts" json:"failed_login_attempts"`
	LockedUntil         pgtype.Timestamptz `db:"locked_until" json:"locked_until"`
	CreatedAt           time.Time          `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time          `db:"updated_at" json:"updated_at"`
}

type WebhookDelivery struct {
	ID             uuid.UUID          `db:"id" json:"id"`
	TenantID       uuid.UUID          `db:"tenant_id" json:"tenant_id"`
	EventID        uuid.UUID          `db:"event_id" json:"event_id"`
	WebhookUrl     string             `db:"webhook_url" json:"webhook_url"`
	HttpStatusCode pgtype.Int4        `db:"http_status_code" json:"http_status_code"`
	ResponseBody   pgtype.Text        `db:"response_body" json:"response_body"`
	Attempts       pgtype.Int4        `db:"attempts" json:"attempts"`
	MaxAttempts    pgtype.Int4        `db:"max_attempts" json:"max_attempts"`
	NextRetryAt    pgtype.Timestamptz `db:"next_retry_at" json:"next_retry_at"`
	DeliveredAt    pgtype.Timestamptz `db:"delivered_at" json:"delivered_at"`
	FailedAt       pgtype.Timestamptz `db:"failed_at" json:"failed_at"`
	CreatedAt      time.Time          `db:"created_at" json:"created_at"`
}
