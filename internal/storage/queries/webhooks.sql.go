// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one

INSERT INTO webhook_deliveries (
    tenant_id, event_id, webhook_url, max_attempts, next_retry_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, event_id, webhook_url, http_status_code, response_body, attempts, max_attempts, next_retry_at, delivered_at, failed_at, created_at
`

type CreateWebhookDeliveryParams struct {
	TenantID    uuid.UUID          `db:"tenant_id" json:"tenant_id"`
	EventID     uuid.UUID          `db:"event_id" json:"event_id"`
	WebhookUrl  string             `db:"webhook_url" json:"webhook_url"`
	MaxAttempts pgtype.Int4        `db:"max_attempts" json:"max_attempts"`
	NextRetryAt pgtype.Timestamptz `db:"next_retry_at" json:"next_retry_at"`
}

// sql/queries/webhooks.sql
func (q *Queries) CreateWebhookDelivery(ctx context.Context, arg CreateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, createWebhookDelivery,
		arg.TenantID,
		arg.EventID,
		arg.WebhookUrl,
		arg.MaxAttempts,
		arg.NextRetryAt,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EventID,
		&i.WebhookUrl,
		&i.HttpStatusCode,
		&i.ResponseBody,
		&i.Attempts,
		&i.MaxAttempts,
		&i.NextRetryAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingWebhookDeliveries = `-- name: GetPendingWebhookDeliveries :many
SELECT id, tenant_id, event_id, webhook_url, http_status_code, response_body, attempts, max_attempts, next_retry_at, delivered_at, failed_at, created_at FROM webhook_deliveries
WHERE next_retry_at IS NOT NULL 
  AND next_retry_at <= NOW()
  AND attempts < max_attempts
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingWebhookDeliveries(ctx context.Context, limit int32) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, getPendingWebhookDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EventID,
			&i.WebhookUrl,
			&i.HttpStatusCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.MaxAttempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.FailedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookDeliveriesByTenant = `-- name: GetWebhookDeliveriesByTenant :many
SELECT id, tenant_id, event_id, webhook_url, http_status_code, response_body, attempts, max_attempts, next_retry_at, delivered_at, failed_at, created_at FROM webhook_deliveries
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetWebhookDeliveriesByTenantParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32     `db:"limit" json:"limit"`
}

func (q *Queries) GetWebhookDeliveriesByTenant(ctx context.Context, arg GetWebhookDeliveriesByTenantParams) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, getWebhookDeliveriesByTenant, arg.TenantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EventID,
			&i.WebhookUrl,
			&i.HttpStatusCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.MaxAttempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.FailedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookDeliveryByID = `-- name: GetWebhookDeliveryByID :one
SELECT id, tenant_id, event_id, webhook_url, http_status_code, response_body, attempts, max_attempts, next_retry_at, delivered_at, failed_at, created_at FROM webhook_deliveries
WHERE id = $1 AND tenant_id = $2
LIMIT 1
`

type GetWebhookDeliveryByIDParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) GetWebhookDeliveryByID(ctx context.Context, arg GetWebhookDeliveryByIDParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, getWebhookDeliveryByID, arg.ID, arg.TenantID)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EventID,
		&i.WebhookUrl,
		&i.HttpStatusCode,
		&i.ResponseBody,
		&i.Attempts,
		&i.MaxAttempts,
		&i.NextRetryAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.CreatedAt,
	)
	return i, err
}

const resetWebhookDeliveryForRetry = `-- name: ResetWebhookDeliveryForRetry :exec
UPDATE webhook_deliveries
SET next_retry_at = NOW(),
    failed_at = NULL
WHERE id = $1
`

func (q *Queries) ResetWebhookDeliveryForRetry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetWebhookDeliveryForRetry, id)
	return err
}

const updateWebhookDeliveryFailure = `-- name: UpdateWebhookDeliveryFailure :exec
UPDATE webhook_deliveries 
SET http_status_code = $2,
    response_body = $3,
    attempts = attempts + 1,
    next_retry_at = CASE 
        WHEN attempts + 1 >= max_attempts THEN NULL
        ELSE NOW() + (INTERVAL '1 minute' * POWER(2, attempts + 1))
    END,
    failed_at = CASE 
        WHEN attempts + 1 >= max_attempts THEN NOW()
        ELSE failed_at
    END
WHERE id = $1
`

type UpdateWebhookDeliveryFailureParams struct {
	ID             uuid.UUID   `db:"id" json:"id"`
	HttpStatusCode pgtype.Int4 `db:"http_status_code" json:"http_status_code"`
	ResponseBody   pgtype.Text `db:"response_body" json:"response_body"`
}

func (q *Queries) UpdateWebhookDeliveryFailure(ctx context.Context, arg UpdateWebhookDeliveryFailureParams) error {
	_, err := q.db.Exec(ctx, updateWebhookDeliveryFailure, arg.ID, arg.HttpStatusCode, arg.ResponseBody)
	return err
}

const updateWebhookDeliverySuccess = `-- name: UpdateWebhookDeliverySuccess :exec
UPDATE webhook_deliveries 
SET http_status_code = $2,
    response_body = $3,
    attempts = attempts + 1,
    delivered_at = NOW(),
    next_retry_at = NULL
WHERE id = $1
`

type UpdateWebhookDeliverySuccessParams struct {
	ID             uuid.UUID   `db:"id" json:"id"`
	HttpStatusCode pgtype.Int4 `db:"http_status_code" json:"http_status_code"`
	ResponseBody   pgtype.Text `db:"response_body" json:"response_body"`
}

func (q *Queries) UpdateWebhookDeliverySuccess(ctx context.Context, arg UpdateWebhookDeliverySuccessParams) error {
	_, err := q.db.Exec(ctx, updateWebhookDeliverySuccess, arg.ID, arg.HttpStatusCode, arg.ResponseBody)
	return err
}
