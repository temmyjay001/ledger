// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package queries

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one

INSERT INTO events (
    tenant_id, aggregate_id, aggregate_type, event_type, 
    event_version, event_data, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING event_id, tenant_id, aggregate_id, aggregate_type, event_type, event_version, event_data, metadata, created_at, sequence_number
`

type CreateEventParams struct {
	TenantID      uuid.UUID       `db:"tenant_id" json:"tenant_id"`
	AggregateID   uuid.UUID       `db:"aggregate_id" json:"aggregate_id"`
	AggregateType string          `db:"aggregate_type" json:"aggregate_type"`
	EventType     string          `db:"event_type" json:"event_type"`
	EventVersion  int32           `db:"event_version" json:"event_version"`
	EventData     json.RawMessage `db:"event_data" json:"event_data"`
	Metadata      json.RawMessage `db:"metadata" json:"metadata"`
}

// sql/queries/events.sql
func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.TenantID,
		arg.AggregateID,
		arg.AggregateType,
		arg.EventType,
		arg.EventVersion,
		arg.EventData,
		arg.Metadata,
	)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.TenantID,
		&i.AggregateID,
		&i.AggregateType,
		&i.EventType,
		&i.EventVersion,
		&i.EventData,
		&i.Metadata,
		&i.CreatedAt,
		&i.SequenceNumber,
	)
	return i, err
}

const getEventsAfterSequence = `-- name: GetEventsAfterSequence :many
SELECT event_id, tenant_id, aggregate_id, aggregate_type, event_type, event_version, event_data, metadata, created_at, sequence_number FROM events 
WHERE sequence_number > $1
ORDER BY sequence_number ASC
LIMIT $2
`

type GetEventsAfterSequenceParams struct {
	SequenceNumber pgtype.Int8 `db:"sequence_number" json:"sequence_number"`
	Limit          int32       `db:"limit" json:"limit"`
}

func (q *Queries) GetEventsAfterSequence(ctx context.Context, arg GetEventsAfterSequenceParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsAfterSequence, arg.SequenceNumber, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.TenantID,
			&i.AggregateID,
			&i.AggregateType,
			&i.EventType,
			&i.EventVersion,
			&i.EventData,
			&i.Metadata,
			&i.CreatedAt,
			&i.SequenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByAggregate = `-- name: GetEventsByAggregate :many
SELECT event_id, tenant_id, aggregate_id, aggregate_type, event_type, event_version, event_data, metadata, created_at, sequence_number FROM events 
WHERE tenant_id = $1 AND aggregate_id = $2
ORDER BY event_version ASC
`

type GetEventsByAggregateParams struct {
	TenantID    uuid.UUID `db:"tenant_id" json:"tenant_id"`
	AggregateID uuid.UUID `db:"aggregate_id" json:"aggregate_id"`
}

func (q *Queries) GetEventsByAggregate(ctx context.Context, arg GetEventsByAggregateParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByAggregate, arg.TenantID, arg.AggregateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.TenantID,
			&i.AggregateID,
			&i.AggregateType,
			&i.EventType,
			&i.EventVersion,
			&i.EventData,
			&i.Metadata,
			&i.CreatedAt,
			&i.SequenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByType = `-- name: GetEventsByType :many
SELECT event_id, tenant_id, aggregate_id, aggregate_type, event_type, event_version, event_data, metadata, created_at, sequence_number FROM events 
WHERE tenant_id = $1 AND event_type = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetEventsByTypeParams struct {
	TenantID  uuid.UUID `db:"tenant_id" json:"tenant_id"`
	EventType string    `db:"event_type" json:"event_type"`
	Limit     int32     `db:"limit" json:"limit"`
	Offset    int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetEventsByType(ctx context.Context, arg GetEventsByTypeParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByType,
		arg.TenantID,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.TenantID,
			&i.AggregateID,
			&i.AggregateType,
			&i.EventType,
			&i.EventVersion,
			&i.EventData,
			&i.Metadata,
			&i.CreatedAt,
			&i.SequenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
