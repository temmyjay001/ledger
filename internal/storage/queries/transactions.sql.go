// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package queries

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createTransaction = `-- name: CreateTransaction :one

INSERT INTO transactions (
    idempotency_key, description, reference, metadata
) VALUES (
    $1, $2, $3, $4
) RETURNING id, idempotency_key, description, reference, status, posted_at, metadata, created_at
`

type CreateTransactionParams struct {
	IdempotencyKey string          `db:"idempotency_key" json:"idempotency_key"`
	Description    string          `db:"description" json:"description"`
	Reference      pgtype.Text     `db:"reference" json:"reference"`
	Metadata       json.RawMessage `db:"metadata" json:"metadata"`
}

// sql/queries/transactions.sql
// Transaction Management Queries for sqlc
// Basic Transaction Operations
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.IdempotencyKey,
		arg.Description,
		arg.Reference,
		arg.Metadata,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.Description,
		&i.Reference,
		&i.Status,
		&i.PostedAt,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createTransactionLine = `-- name: CreateTransactionLine :one
INSERT INTO transaction_lines (
    transaction_id, account_id, amount, side, currency, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, transaction_id, account_id, amount, side, currency, metadata, created_at
`

type CreateTransactionLineParams struct {
	TransactionID uuid.UUID           `db:"transaction_id" json:"transaction_id"`
	AccountID     uuid.UUID           `db:"account_id" json:"account_id"`
	Amount        decimal.Decimal     `db:"amount" json:"amount"`
	Side          TransactionSideEnum `db:"side" json:"side"`
	Currency      string              `db:"currency" json:"currency"`
	Metadata      json.RawMessage     `db:"metadata" json:"metadata"`
}

// Transaction Line Operations
func (q *Queries) CreateTransactionLine(ctx context.Context, arg CreateTransactionLineParams) (TransactionLine, error) {
	row := q.db.QueryRow(ctx, createTransactionLine,
		arg.TransactionID,
		arg.AccountID,
		arg.Amount,
		arg.Side,
		arg.Currency,
		arg.Metadata,
	)
	var i TransactionLine
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.Amount,
		&i.Side,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, idempotency_key, description, reference, status, posted_at, metadata, created_at FROM transactions 
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.Description,
		&i.Reference,
		&i.Status,
		&i.PostedAt,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionByIdempotencyKey = `-- name: GetTransactionByIdempotencyKey :one
SELECT id, idempotency_key, description, reference, status, posted_at, metadata, created_at FROM transactions 
WHERE idempotency_key = $1 LIMIT 1
`

func (q *Queries) GetTransactionByIdempotencyKey(ctx context.Context, idempotencyKey string) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByIdempotencyKey, idempotencyKey)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.Description,
		&i.Reference,
		&i.Status,
		&i.PostedAt,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionLines = `-- name: GetTransactionLines :many
SELECT 
    tl.id, tl.transaction_id, tl.account_id, tl.amount, tl.side, tl.currency, tl.metadata, tl.created_at,
    a.code as account_code,
    a.name as account_name
FROM transaction_lines tl
JOIN accounts a ON tl.account_id = a.id
WHERE tl.transaction_id = $1
ORDER BY tl.created_at
`

type GetTransactionLinesRow struct {
	ID            uuid.UUID           `db:"id" json:"id"`
	TransactionID uuid.UUID           `db:"transaction_id" json:"transaction_id"`
	AccountID     uuid.UUID           `db:"account_id" json:"account_id"`
	Amount        decimal.Decimal     `db:"amount" json:"amount"`
	Side          TransactionSideEnum `db:"side" json:"side"`
	Currency      string              `db:"currency" json:"currency"`
	Metadata      json.RawMessage     `db:"metadata" json:"metadata"`
	CreatedAt     time.Time           `db:"created_at" json:"created_at"`
	AccountCode   string              `db:"account_code" json:"account_code"`
	AccountName   string              `db:"account_name" json:"account_name"`
}

func (q *Queries) GetTransactionLines(ctx context.Context, transactionID uuid.UUID) ([]GetTransactionLinesRow, error) {
	rows, err := q.db.Query(ctx, getTransactionLines, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionLinesRow{}
	for rows.Next() {
		var i GetTransactionLinesRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.AccountID,
			&i.Amount,
			&i.Side,
			&i.Currency,
			&i.Metadata,
			&i.CreatedAt,
			&i.AccountCode,
			&i.AccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionWithLines = `-- name: GetTransactionWithLines :one
SELECT 
    t.id, t.idempotency_key, t.description, t.reference, t.status, t.posted_at, t.metadata, t.created_at,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', tl.id,
                'account_id', tl.account_id,
                'account_code', a.code,
                'account_name', a.name,
                'amount', tl.amount,
                'side', tl.side,
                'currency', tl.currency,
                'metadata', tl.metadata,
                'created_at', tl.created_at
            ) ORDER BY tl.created_at
        ) FILTER (WHERE tl.id IS NOT NULL),
        '[]'::json
    ) as lines
FROM transactions t
LEFT JOIN transaction_lines tl ON t.id = tl.transaction_id
LEFT JOIN accounts a ON tl.account_id = a.id
WHERE t.id = $1
GROUP BY t.id, t.idempotency_key, t.description, t.reference, t.status, t.posted_at, t.metadata, t.created_at
`

type GetTransactionWithLinesRow struct {
	ID             uuid.UUID                 `db:"id" json:"id"`
	IdempotencyKey string                    `db:"idempotency_key" json:"idempotency_key"`
	Description    string                    `db:"description" json:"description"`
	Reference      pgtype.Text               `db:"reference" json:"reference"`
	Status         NullTransactionStatusEnum `db:"status" json:"status"`
	PostedAt       time.Time                 `db:"posted_at" json:"posted_at"`
	Metadata       json.RawMessage           `db:"metadata" json:"metadata"`
	CreatedAt      time.Time                 `db:"created_at" json:"created_at"`
	Lines          interface{}               `db:"lines" json:"lines"`
}

func (q *Queries) GetTransactionWithLines(ctx context.Context, id uuid.UUID) (GetTransactionWithLinesRow, error) {
	row := q.db.QueryRow(ctx, getTransactionWithLines, id)
	var i GetTransactionWithLinesRow
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.Description,
		&i.Reference,
		&i.Status,
		&i.PostedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.Lines,
	)
	return i, err
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, idempotency_key, description, reference, status, posted_at, metadata, created_at FROM transactions
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListTransactionsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

// Advanced Transaction Queries
func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.Description,
			&i.Reference,
			&i.Status,
			&i.PostedAt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByAccount = `-- name: ListTransactionsByAccount :many
SELECT DISTINCT t.id, t.idempotency_key, t.description, t.reference, t.status, t.posted_at, t.metadata, t.created_at FROM transactions t
JOIN transaction_lines tl ON t.id = tl.transaction_id
JOIN accounts a ON tl.account_id = a.id
WHERE a.code = $1
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByAccountParams struct {
	Code   string `db:"code" json:"code"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListTransactionsByAccount(ctx context.Context, arg ListTransactionsByAccountParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByAccount, arg.Code, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.Description,
			&i.Reference,
			&i.Status,
			&i.PostedAt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByAccountAndDateRange = `-- name: ListTransactionsByAccountAndDateRange :many
SELECT DISTINCT t.id, t.idempotency_key, t.description, t.reference, t.status, t.posted_at, t.metadata, t.created_at FROM transactions t
JOIN transaction_lines tl ON t.id = tl.transaction_id
JOIN accounts a ON tl.account_id = a.id
WHERE a.code = $1 
AND t.posted_at BETWEEN $2 AND $3
ORDER BY t.created_at DESC
LIMIT $4 OFFSET $5
`

type ListTransactionsByAccountAndDateRangeParams struct {
	Code       string    `db:"code" json:"code"`
	PostedAt   time.Time `db:"posted_at" json:"posted_at"`
	PostedAt_2 time.Time `db:"posted_at_2" json:"posted_at_2"`
	Limit      int32     `db:"limit" json:"limit"`
	Offset     int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListTransactionsByAccountAndDateRange(ctx context.Context, arg ListTransactionsByAccountAndDateRangeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByAccountAndDateRange,
		arg.Code,
		arg.PostedAt,
		arg.PostedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.Description,
			&i.Reference,
			&i.Status,
			&i.PostedAt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByDateRange = `-- name: ListTransactionsByDateRange :many
SELECT id, idempotency_key, description, reference, status, posted_at, metadata, created_at FROM transactions
WHERE posted_at BETWEEN $1 AND $2
ORDER BY posted_at DESC
LIMIT $3 OFFSET $4
`

type ListTransactionsByDateRangeParams struct {
	PostedAt   time.Time `db:"posted_at" json:"posted_at"`
	PostedAt_2 time.Time `db:"posted_at_2" json:"posted_at_2"`
	Limit      int32     `db:"limit" json:"limit"`
	Offset     int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListTransactionsByDateRange(ctx context.Context, arg ListTransactionsByDateRangeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByDateRange,
		arg.PostedAt,
		arg.PostedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.Description,
			&i.Reference,
			&i.Status,
			&i.PostedAt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transactions
SET 
    status = $2,
    posted_at = CASE WHEN $2 = 'posted' ::public.transaction_status_enum THEN NOW() ELSE posted_at END
WHERE id = $1
RETURNING id, idempotency_key, description, reference, status, posted_at, metadata, created_at
`

type UpdateTransactionStatusParams struct {
	ID     uuid.UUID                 `db:"id" json:"id"`
	Status NullTransactionStatusEnum `db:"status" json:"status"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionStatus, arg.ID, arg.Status)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.Description,
		&i.Reference,
		&i.Status,
		&i.PostedAt,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}
