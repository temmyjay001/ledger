// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package queries

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createAccount = `-- name: CreateAccount :one

INSERT INTO accounts (
    code,
    name, 
    account_type,
    parent_id,
    currency,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at
`

type CreateAccountParams struct {
	Code        string          `db:"code" json:"code"`
	Name        string          `db:"name" json:"name"`
	AccountType AccountTypeEnum `db:"account_type" json:"account_type"`
	ParentID    *uuid.UUID      `db:"parent_id" json:"parent_id"`
	Currency    string          `db:"currency" json:"currency"`
	Metadata    json.RawMessage `db:"metadata" json:"metadata"`
}

// sql/queries/accounts.sql
// Account Management Queries for sqlc
func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.Code,
		arg.Name,
		arg.AccountType,
		arg.ParentID,
		arg.Currency,
		arg.Metadata,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.AccountType,
		&i.ParentID,
		&i.Currency,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAccountBalance = `-- name: CreateAccountBalance :one

INSERT INTO account_balances (
    account_id,
    currency,
    balance
) VALUES (
    $1, $2, $3
) RETURNING account_id, currency, balance, version, updated_at
`

type CreateAccountBalanceParams struct {
	AccountID uuid.UUID       `db:"account_id" json:"account_id"`
	Currency  string          `db:"currency" json:"currency"`
	Balance   decimal.Decimal `db:"balance" json:"balance"`
}

// Account Balance Operations
func (q *Queries) CreateAccountBalance(ctx context.Context, arg CreateAccountBalanceParams) (AccountBalance, error) {
	row := q.db.QueryRow(ctx, createAccountBalance, arg.AccountID, arg.Currency, arg.Balance)
	var i AccountBalance
	err := row.Scan(
		&i.AccountID,
		&i.Currency,
		&i.Balance,
		&i.Version,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateAccount = `-- name: DeactivateAccount :one
UPDATE accounts
SET 
    is_active = false,
    updated_at = NOW()
WHERE id = $1
RETURNING id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at
`

func (q *Queries) DeactivateAccount(ctx context.Context, id uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, deactivateAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.AccountType,
		&i.ParentID,
		&i.Currency,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountBalance = `-- name: GetAccountBalance :one
SELECT account_id, currency, balance, version, updated_at FROM account_balances
WHERE account_id = $1 AND currency = $2
`

type GetAccountBalanceParams struct {
	AccountID uuid.UUID `db:"account_id" json:"account_id"`
	Currency  string    `db:"currency" json:"currency"`
}

func (q *Queries) GetAccountBalance(ctx context.Context, arg GetAccountBalanceParams) (AccountBalance, error) {
	row := q.db.QueryRow(ctx, getAccountBalance, arg.AccountID, arg.Currency)
	var i AccountBalance
	err := row.Scan(
		&i.AccountID,
		&i.Currency,
		&i.Balance,
		&i.Version,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountBalanceForUpdate = `-- name: GetAccountBalanceForUpdate :one
SELECT account_id, currency, balance, version, updated_at FROM account_balances
WHERE account_id = $1 AND currency = $2
FOR UPDATE
`

type GetAccountBalanceForUpdateParams struct {
	AccountID uuid.UUID `db:"account_id" json:"account_id"`
	Currency  string    `db:"currency" json:"currency"`
}

func (q *Queries) GetAccountBalanceForUpdate(ctx context.Context, arg GetAccountBalanceForUpdateParams) (AccountBalance, error) {
	row := q.db.QueryRow(ctx, getAccountBalanceForUpdate, arg.AccountID, arg.Currency)
	var i AccountBalance
	err := row.Scan(
		&i.AccountID,
		&i.Currency,
		&i.Balance,
		&i.Version,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountBalanceHistory = `-- name: GetAccountBalanceHistory :many
SELECT 
    ab.account_id,
    ab.currency,
    ab.balance,
    ab.version,
    ab.updated_at
FROM account_balances ab
WHERE ab.account_id = $1 
AND ab.currency = $2
AND ab.updated_at >= $3
ORDER BY ab.updated_at DESC
`

type GetAccountBalanceHistoryParams struct {
	AccountID uuid.UUID `db:"account_id" json:"account_id"`
	Currency  string    `db:"currency" json:"currency"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetAccountBalanceHistory(ctx context.Context, arg GetAccountBalanceHistoryParams) ([]AccountBalance, error) {
	rows, err := q.db.Query(ctx, getAccountBalanceHistory, arg.AccountID, arg.Currency, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountBalance{}
	for rows.Next() {
		var i AccountBalance
		if err := rows.Scan(
			&i.AccountID,
			&i.Currency,
			&i.Balance,
			&i.Version,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountBalanceSummary = `-- name: GetAccountBalanceSummary :many
SELECT 
    a.account_type,
    ab.currency,
    SUM(ab.balance) as total_balance,
    COUNT(a.id) as account_count
FROM accounts a
JOIN account_balances ab ON a.id = ab.account_id
WHERE a.is_active = true
GROUP BY a.account_type, ab.currency
ORDER BY a.account_type, ab.currency
`

type GetAccountBalanceSummaryRow struct {
	AccountType  AccountTypeEnum `db:"account_type" json:"account_type"`
	Currency     string          `db:"currency" json:"currency"`
	TotalBalance int64           `db:"total_balance" json:"total_balance"`
	AccountCount int64           `db:"account_count" json:"account_count"`
}

func (q *Queries) GetAccountBalanceSummary(ctx context.Context) ([]GetAccountBalanceSummaryRow, error) {
	rows, err := q.db.Query(ctx, getAccountBalanceSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountBalanceSummaryRow{}
	for rows.Next() {
		var i GetAccountBalanceSummaryRow
		if err := rows.Scan(
			&i.AccountType,
			&i.Currency,
			&i.TotalBalance,
			&i.AccountCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountBalances = `-- name: GetAccountBalances :many
SELECT account_id, currency, balance, version, updated_at FROM account_balances
WHERE account_id = $1
ORDER BY currency
`

func (q *Queries) GetAccountBalances(ctx context.Context, accountID uuid.UUID) ([]AccountBalance, error) {
	rows, err := q.db.Query(ctx, getAccountBalances, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountBalance{}
	for rows.Next() {
		var i AccountBalance
		if err := rows.Scan(
			&i.AccountID,
			&i.Currency,
			&i.Balance,
			&i.Version,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountByCode = `-- name: GetAccountByCode :one
SELECT id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at FROM accounts
WHERE code = $1 AND is_active = true
`

func (q *Queries) GetAccountByCode(ctx context.Context, code string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByCode, code)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.AccountType,
		&i.ParentID,
		&i.Currency,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at FROM accounts 
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetAccountByID(ctx context.Context, id uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.AccountType,
		&i.ParentID,
		&i.Currency,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountHierarchy = `-- name: GetAccountHierarchy :many
WITH RECURSIVE account_hierarchy AS (
    -- Base case: start with root accounts (no parent)
    SELECT 
        id,
        code,
        name,
        account_type,
        parent_id,
        currency,
        metadata,
        is_active,
        created_at,
        updated_at,
        0 as level,
        code::text as path
    FROM accounts
    WHERE parent_id IS NULL AND is_active = true
    
    UNION ALL
    
    -- Recursive case: get children
    SELECT 
        a.id,
        a.code,
        a.name,
        a.account_type,
        a.parent_id,
        a.currency,
        a.metadata,
        a.is_active,
        a.created_at,
        a.updated_at,
        ah.level + 1,
        ah.path || '/' || a.code
    FROM accounts a
    JOIN account_hierarchy ah ON a.parent_id = ah.id
    WHERE a.is_active = true
)
SELECT id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at, level, path FROM account_hierarchy
ORDER BY path
`

type GetAccountHierarchyRow struct {
	ID          uuid.UUID       `db:"id" json:"id"`
	Code        string          `db:"code" json:"code"`
	Name        string          `db:"name" json:"name"`
	AccountType AccountTypeEnum `db:"account_type" json:"account_type"`
	ParentID    *uuid.UUID      `db:"parent_id" json:"parent_id"`
	Currency    string          `db:"currency" json:"currency"`
	Metadata    json.RawMessage `db:"metadata" json:"metadata"`
	IsActive    bool            `db:"is_active" json:"is_active"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
	Level       int32           `db:"level" json:"level"`
	Path        string          `db:"path" json:"path"`
}

func (q *Queries) GetAccountHierarchy(ctx context.Context) ([]GetAccountHierarchyRow, error) {
	rows, err := q.db.Query(ctx, getAccountHierarchy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountHierarchyRow{}
	for rows.Next() {
		var i GetAccountHierarchyRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.AccountType,
			&i.ParentID,
			&i.Currency,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Level,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountStats = `-- name: GetAccountStats :one
SELECT 
    COUNT(*) as total_accounts,
    COUNT(*) FILTER (WHERE account_type = 'asset') as asset_accounts,
    COUNT(*) FILTER (WHERE account_type = 'liability') as liability_accounts,
    COUNT(*) FILTER (WHERE account_type = 'equity') as equity_accounts,
    COUNT(*) FILTER (WHERE account_type = 'revenue') as revenue_accounts,
    COUNT(*) FILTER (WHERE account_type = 'expense') as expense_accounts,
    COUNT(DISTINCT currency) as currencies_count
FROM accounts
WHERE is_active = true
`

type GetAccountStatsRow struct {
	TotalAccounts     int64 `db:"total_accounts" json:"total_accounts"`
	AssetAccounts     int64 `db:"asset_accounts" json:"asset_accounts"`
	LiabilityAccounts int64 `db:"liability_accounts" json:"liability_accounts"`
	EquityAccounts    int64 `db:"equity_accounts" json:"equity_accounts"`
	RevenueAccounts   int64 `db:"revenue_accounts" json:"revenue_accounts"`
	ExpenseAccounts   int64 `db:"expense_accounts" json:"expense_accounts"`
	CurrenciesCount   int64 `db:"currencies_count" json:"currencies_count"`
}

func (q *Queries) GetAccountStats(ctx context.Context) (GetAccountStatsRow, error) {
	row := q.db.QueryRow(ctx, getAccountStats)
	var i GetAccountStatsRow
	err := row.Scan(
		&i.TotalAccounts,
		&i.AssetAccounts,
		&i.LiabilityAccounts,
		&i.EquityAccounts,
		&i.RevenueAccounts,
		&i.ExpenseAccounts,
		&i.CurrenciesCount,
	)
	return i, err
}

const getAccountWithBalance = `-- name: GetAccountWithBalance :one

SELECT 
    a.id, a.code, a.name, a.account_type, a.parent_id, a.currency, a.metadata, a.is_active, a.created_at, a.updated_at,
    ab.balance,
    ab.currency as balance_currency,
    ab.version as balance_version,
    ab.updated_at as balance_updated_at
FROM accounts a
LEFT JOIN account_balances ab ON a.id = ab.account_id AND ab.currency = $2
WHERE a.id = $1 AND a.is_active = true
`

type GetAccountWithBalanceParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	Currency string    `db:"currency" json:"currency"`
}

type GetAccountWithBalanceRow struct {
	ID               uuid.UUID       `db:"id" json:"id"`
	Code             string          `db:"code" json:"code"`
	Name             string          `db:"name" json:"name"`
	AccountType      AccountTypeEnum `db:"account_type" json:"account_type"`
	ParentID         *uuid.UUID      `db:"parent_id" json:"parent_id"`
	Currency         string          `db:"currency" json:"currency"`
	Metadata         json.RawMessage `db:"metadata" json:"metadata"`
	IsActive         bool            `db:"is_active" json:"is_active"`
	CreatedAt        time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time       `db:"updated_at" json:"updated_at"`
	Balance          decimal.Decimal `db:"balance" json:"balance"`
	BalanceCurrency  pgtype.Text     `db:"balance_currency" json:"balance_currency"`
	BalanceVersion   pgtype.Int8     `db:"balance_version" json:"balance_version"`
	BalanceUpdatedAt time.Time       `db:"balance_updated_at" json:"balance_updated_at"`
}

// Utility queries for reporting and validation
func (q *Queries) GetAccountWithBalance(ctx context.Context, arg GetAccountWithBalanceParams) (GetAccountWithBalanceRow, error) {
	row := q.db.QueryRow(ctx, getAccountWithBalance, arg.ID, arg.Currency)
	var i GetAccountWithBalanceRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.AccountType,
		&i.ParentID,
		&i.Currency,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Balance,
		&i.BalanceCurrency,
		&i.BalanceVersion,
		&i.BalanceUpdatedAt,
	)
	return i, err
}

const getAllBalanceSummary = `-- name: GetAllBalanceSummary :one
SELECT 
    'ALL'::text as currency,
    COUNT(DISTINCT a.id)::bigint as total_accounts,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE a2.account_type = 'asset' AND a2.is_active = true
    ) as total_assets,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE a2.account_type = 'liability' AND a2.is_active = true
    ) as total_liabilities,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE a2.account_type = 'equity' AND a2.is_active = true
    ) as total_equity,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE a2.account_type = 'revenue' AND a2.is_active = true
    ) as total_revenue,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE a2.account_type = 'expense' AND a2.is_active = true
    ) as total_expenses,
    NOW() as generated_at
FROM account_balances ab
JOIN accounts a ON ab.account_id = a.id
WHERE a.is_active = true
LIMIT 1
`

type GetAllBalanceSummaryRow struct {
	Currency         string      `db:"currency" json:"currency"`
	TotalAccounts    int64       `db:"total_accounts" json:"total_accounts"`
	TotalAssets      interface{} `db:"total_assets" json:"total_assets"`
	TotalLiabilities interface{} `db:"total_liabilities" json:"total_liabilities"`
	TotalEquity      interface{} `db:"total_equity" json:"total_equity"`
	TotalRevenue     interface{} `db:"total_revenue" json:"total_revenue"`
	TotalExpenses    interface{} `db:"total_expenses" json:"total_expenses"`
	GeneratedAt      interface{} `db:"generated_at" json:"generated_at"`
}

func (q *Queries) GetAllBalanceSummary(ctx context.Context) (GetAllBalanceSummaryRow, error) {
	row := q.db.QueryRow(ctx, getAllBalanceSummary)
	var i GetAllBalanceSummaryRow
	err := row.Scan(
		&i.Currency,
		&i.TotalAccounts,
		&i.TotalAssets,
		&i.TotalLiabilities,
		&i.TotalEquity,
		&i.TotalRevenue,
		&i.TotalExpenses,
		&i.GeneratedAt,
	)
	return i, err
}

const getBalanceSummaryByAccountType = `-- name: GetBalanceSummaryByAccountType :many
SELECT 
    a.account_type,
    ab.currency,
    COUNT(*)::bigint as account_count,
    COALESCE(SUM(ab.balance), 0::numeric(20,4)) as total_balance,
    COALESCE(AVG(ab.balance), 0::numeric(20,4)) as average_balance,
    COALESCE(MIN(ab.balance), 0::numeric(20,4)) as minimum_balance,
    COALESCE(MAX(ab.balance), 0::numeric(20,4)) as maximum_balance
FROM account_balances ab
JOIN accounts a ON ab.account_id = a.id
WHERE a.is_active = true
  AND ($1::text IS NULL OR ab.currency = $1)
GROUP BY a.account_type, ab.currency
ORDER BY a.account_type, ab.currency
`

type GetBalanceSummaryByAccountTypeRow struct {
	AccountType    AccountTypeEnum `db:"account_type" json:"account_type"`
	Currency       string          `db:"currency" json:"currency"`
	AccountCount   int64           `db:"account_count" json:"account_count"`
	TotalBalance   interface{}     `db:"total_balance" json:"total_balance"`
	AverageBalance interface{}     `db:"average_balance" json:"average_balance"`
	MinimumBalance interface{}     `db:"minimum_balance" json:"minimum_balance"`
	MaximumBalance interface{}     `db:"maximum_balance" json:"maximum_balance"`
}

func (q *Queries) GetBalanceSummaryByAccountType(ctx context.Context, dollar_1 string) ([]GetBalanceSummaryByAccountTypeRow, error) {
	rows, err := q.db.Query(ctx, getBalanceSummaryByAccountType, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBalanceSummaryByAccountTypeRow{}
	for rows.Next() {
		var i GetBalanceSummaryByAccountTypeRow
		if err := rows.Scan(
			&i.AccountType,
			&i.Currency,
			&i.AccountCount,
			&i.TotalBalance,
			&i.AverageBalance,
			&i.MinimumBalance,
			&i.MaximumBalance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBalanceSummaryByCurrency = `-- name: GetBalanceSummaryByCurrency :one
SELECT 
    $1::text as currency,
    COUNT(DISTINCT a.id)::bigint as total_accounts,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE ab2.currency = $1 AND a2.account_type = 'asset' AND a2.is_active = true
    ) as total_assets,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE ab2.currency = $1 AND a2.account_type = 'liability' AND a2.is_active = true
    ) as total_liabilities,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE ab2.currency = $1 AND a2.account_type = 'equity' AND a2.is_active = true
    ) as total_equity,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE ab2.currency = $1 AND a2.account_type = 'revenue' AND a2.is_active = true
    ) as total_revenue,
    (
        SELECT COALESCE(SUM(ab2.balance), 0::numeric(20,4))
        FROM account_balances ab2
        JOIN accounts a2 ON ab2.account_id = a2.id
        WHERE ab2.currency = $1 AND a2.account_type = 'expense' AND a2.is_active = true
    ) as total_expenses,
    NOW() as generated_at
FROM account_balances ab
JOIN accounts a ON ab.account_id = a.id
WHERE ab.currency = $1 AND a.is_active = true
LIMIT 1
`

type GetBalanceSummaryByCurrencyRow struct {
	Currency         string      `db:"currency" json:"currency"`
	TotalAccounts    int64       `db:"total_accounts" json:"total_accounts"`
	TotalAssets      interface{} `db:"total_assets" json:"total_assets"`
	TotalLiabilities interface{} `db:"total_liabilities" json:"total_liabilities"`
	TotalEquity      interface{} `db:"total_equity" json:"total_equity"`
	TotalRevenue     interface{} `db:"total_revenue" json:"total_revenue"`
	TotalExpenses    interface{} `db:"total_expenses" json:"total_expenses"`
	GeneratedAt      interface{} `db:"generated_at" json:"generated_at"`
}

func (q *Queries) GetBalanceSummaryByCurrency(ctx context.Context, dollar_1 string) (GetBalanceSummaryByCurrencyRow, error) {
	row := q.db.QueryRow(ctx, getBalanceSummaryByCurrency, dollar_1)
	var i GetBalanceSummaryByCurrencyRow
	err := row.Scan(
		&i.Currency,
		&i.TotalAccounts,
		&i.TotalAssets,
		&i.TotalLiabilities,
		&i.TotalEquity,
		&i.TotalRevenue,
		&i.TotalExpenses,
		&i.GeneratedAt,
	)
	return i, err
}

const listAccountBalancesByCurrency = `-- name: ListAccountBalancesByCurrency :many
SELECT 
    a.id as account_id,
    a.code,
    a.name,
    a.account_type,
    ab.currency,
    ab.balance,
    ab.version,
    ab.updated_at as balance_updated_at
FROM accounts a
LEFT JOIN account_balances ab ON a.id = ab.account_id
WHERE ab.currency = $1 AND a.is_active = true
ORDER BY a.code
`

type ListAccountBalancesByCurrencyRow struct {
	AccountID        uuid.UUID       `db:"account_id" json:"account_id"`
	Code             string          `db:"code" json:"code"`
	Name             string          `db:"name" json:"name"`
	AccountType      AccountTypeEnum `db:"account_type" json:"account_type"`
	Currency         pgtype.Text     `db:"currency" json:"currency"`
	Balance          decimal.Decimal `db:"balance" json:"balance"`
	Version          pgtype.Int8     `db:"version" json:"version"`
	BalanceUpdatedAt time.Time       `db:"balance_updated_at" json:"balance_updated_at"`
}

func (q *Queries) ListAccountBalancesByCurrency(ctx context.Context, currency string) ([]ListAccountBalancesByCurrencyRow, error) {
	rows, err := q.db.Query(ctx, listAccountBalancesByCurrency, currency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountBalancesByCurrencyRow{}
	for rows.Next() {
		var i ListAccountBalancesByCurrencyRow
		if err := rows.Scan(
			&i.AccountID,
			&i.Code,
			&i.Name,
			&i.AccountType,
			&i.Currency,
			&i.Balance,
			&i.Version,
			&i.BalanceUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at FROM accounts
WHERE is_active = true
ORDER BY code ASC
`

func (q *Queries) ListAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.AccountType,
			&i.ParentID,
			&i.Currency,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByParent = `-- name: ListAccountsByParent :many
SELECT id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at FROM accounts
WHERE parent_id = $1 AND is_active = true
ORDER BY code ASC
`

func (q *Queries) ListAccountsByParent(ctx context.Context, parentID *uuid.UUID) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccountsByParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.AccountType,
			&i.ParentID,
			&i.Currency,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByParentCode = `-- name: ListAccountsByParentCode :many
SELECT a.id, a.code, a.name, a.account_type, a.parent_id, a.currency, a.metadata, a.is_active, a.created_at, a.updated_at FROM accounts a
JOIN accounts parent ON a.parent_id = parent.id
WHERE parent.code = $1 AND a.is_active = true
ORDER BY a.code ASC
`

func (q *Queries) ListAccountsByParentCode(ctx context.Context, code string) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccountsByParentCode, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.AccountType,
			&i.ParentID,
			&i.Currency,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByType = `-- name: ListAccountsByType :many
SELECT id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at FROM accounts
WHERE account_type = $1 AND is_active = true
ORDER BY code ASC
`

func (q *Queries) ListAccountsByType(ctx context.Context, accountType AccountTypeEnum) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccountsByType, accountType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.AccountType,
			&i.ParentID,
			&i.Currency,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsWithBalances = `-- name: ListAccountsWithBalances :many
SELECT 
    a.id,
    a.code,
    a.name,
    a.account_type,
    a.parent_id,
    a.currency as default_currency,
    a.metadata,
    a.created_at,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'currency', ab.currency,
                'balance', ab.balance,
                'version', ab.version,
                'updated_at', ab.updated_at
            ) ORDER BY ab.currency
        ) FILTER (WHERE ab.currency IS NOT NULL),
        '[]'::json
    ) as balances
FROM accounts a
LEFT JOIN account_balances ab ON a.id = ab.account_id
WHERE a.is_active = true
GROUP BY a.id, a.code, a.name, a.account_type, a.parent_id, a.currency, a.metadata, a.created_at
ORDER BY a.code
`

type ListAccountsWithBalancesRow struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	Code            string          `db:"code" json:"code"`
	Name            string          `db:"name" json:"name"`
	AccountType     AccountTypeEnum `db:"account_type" json:"account_type"`
	ParentID        *uuid.UUID      `db:"parent_id" json:"parent_id"`
	DefaultCurrency string          `db:"default_currency" json:"default_currency"`
	Metadata        json.RawMessage `db:"metadata" json:"metadata"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	Balances        interface{}     `db:"balances" json:"balances"`
}

func (q *Queries) ListAccountsWithBalances(ctx context.Context) ([]ListAccountsWithBalancesRow, error) {
	rows, err := q.db.Query(ctx, listAccountsWithBalances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountsWithBalancesRow{}
	for rows.Next() {
		var i ListAccountsWithBalancesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.AccountType,
			&i.ParentID,
			&i.DefaultCurrency,
			&i.Metadata,
			&i.CreatedAt,
			&i.Balances,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAccounts = `-- name: SearchAccounts :many
SELECT id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at FROM accounts
WHERE 
    is_active = true AND
    (
        code ILIKE '%' || $1 || '%' OR
        name ILIKE '%' || $1 || '%'
    )
ORDER BY code
LIMIT $2
`

type SearchAccountsParams struct {
	Column1 pgtype.Text `db:"column_1" json:"column_1"`
	Limit   int32       `db:"limit" json:"limit"`
}

func (q *Queries) SearchAccounts(ctx context.Context, arg SearchAccountsParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, searchAccounts, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.AccountType,
			&i.ParentID,
			&i.Currency,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET 
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata),
    updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, code, name, account_type, parent_id, currency, metadata, is_active, created_at, updated_at
`

type UpdateAccountParams struct {
	ID       uuid.UUID       `db:"id" json:"id"`
	Name     string          `db:"name" json:"name"`
	Metadata json.RawMessage `db:"metadata" json:"metadata"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount, arg.ID, arg.Name, arg.Metadata)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.AccountType,
		&i.ParentID,
		&i.Currency,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccountBalance = `-- name: UpdateAccountBalance :one
UPDATE account_balances
SET 
    balance = $3,
    version = version + 1,
    updated_at = NOW()
WHERE account_id = $1 AND currency = $2 AND version = $4
RETURNING account_id, currency, balance, version, updated_at
`

type UpdateAccountBalanceParams struct {
	AccountID uuid.UUID       `db:"account_id" json:"account_id"`
	Currency  string          `db:"currency" json:"currency"`
	Balance   decimal.Decimal `db:"balance" json:"balance"`
	Version   int64           `db:"version" json:"version"`
}

func (q *Queries) UpdateAccountBalance(ctx context.Context, arg UpdateAccountBalanceParams) (AccountBalance, error) {
	row := q.db.QueryRow(ctx, updateAccountBalance,
		arg.AccountID,
		arg.Currency,
		arg.Balance,
		arg.Version,
	)
	var i AccountBalance
	err := row.Scan(
		&i.AccountID,
		&i.Currency,
		&i.Balance,
		&i.Version,
		&i.UpdatedAt,
	)
	return i, err
}

const validateAccountCode = `-- name: ValidateAccountCode :one
SELECT EXISTS(
    SELECT 1 FROM accounts 
    WHERE code = $1 AND is_active = true
) as exists
`

func (q *Queries) ValidateAccountCode(ctx context.Context, code string) (bool, error) {
	row := q.db.QueryRow(ctx, validateAccountCode, code)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const validateParentAccount = `-- name: ValidateParentAccount :one
SELECT 
    id,
    account_type,
    is_active
FROM accounts
WHERE id = $1
`

type ValidateParentAccountRow struct {
	ID          uuid.UUID       `db:"id" json:"id"`
	AccountType AccountTypeEnum `db:"account_type" json:"account_type"`
	IsActive    bool            `db:"is_active" json:"is_active"`
}

func (q *Queries) ValidateParentAccount(ctx context.Context, id uuid.UUID) (ValidateParentAccountRow, error) {
	row := q.db.QueryRow(ctx, validateParentAccount, id)
	var i ValidateParentAccountRow
	err := row.Scan(&i.ID, &i.AccountType, &i.IsActive)
	return i, err
}
